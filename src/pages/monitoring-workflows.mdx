***

title: Monitoring Workflows
description: Detailed monitoring workflows and processes for Uptime Watcher
---------------------------------------------------------------------------

{/\* eslint-disable no-unused-vars,@eslint-community/eslint-comments/disable-enable-pair -- Layout component consumed by MDX JSX \*/}
import Layout from '@theme/Layout';
import Mermaid from '@theme/Mermaid';

export default function MonitoringWorkflows() {
return ( <Layout
   title="Monitoring Workflows"
   description="Detailed monitoring workflows and processes for Uptime Watcher"
 > <div className="container margin-vert--lg"> <div className="row"> <div className="col">

# Monitoring Workflows

This page showcases the various monitoring workflows and processes used in Uptime Watcher.

## Site Monitoring Lifecycle

This flowchart shows the complete lifecycle of monitoring a site from creation to deletion:

\<Mermaid value={\`flowchart TD
Start(\[User Wants to Monitor Site]) --> Input\[Enter Site Details]
Input --> Validate{Validate Input}
Validate -->|Invalid| Error\[Show Error Message]
Error --> Input
Validate -->|Valid| Create\[Create Site Record]
Create --> Configure\[Configure Monitor Settings]
Configure --> Schedule\[Schedule Monitoring]

```
Schedule --> Monitor{Monitor Site}
Monitor -->|Success| LogSuccess[Log Success Result]
Monitor -->|Failure| LogFailure[Log Failure Result]
Monitor -->|Timeout| LogTimeout[Log Timeout Result]

LogSuccess --> Store[Store in Database]
LogFailure --> Store
LogTimeout --> Store

Store --> Notify{Send Notifications?}
Notify -->|Yes| SendNotification[Send Alert/Email]
Notify -->|No| Wait[Wait for Next Interval]
SendNotification --> Wait

Wait --> Check{Site Still Active?}
Check -->|Yes| Monitor
Check -->|No| Cleanup[Cleanup Resources]
Cleanup --> End([Monitoring Stopped])

%% Styling
classDef startEnd fill:#e1f5fe,stroke:#0277bd,color:#000000
classDef process fill:#e8f5e8,stroke:#2e7d32,color:#000000
classDef decision fill:#fff3e0,stroke:#ef6c00,color:#000000
classDef error fill:#ffebee,stroke:#c62828,color:#000000
classDef data fill:#f3e5f5,stroke:#7b1fa2,color:#000000

class Start,End startEnd
class Input,Create,Configure,Schedule,LogSuccess,LogFailure,LogTimeout,SendNotification,Wait,Cleanup process
class Validate,Monitor,Notify,Check decision
class Error error
class Store data`} />
```

## Monitor Type Decision Tree

This diagram helps users choose the appropriate monitor type for their needs:

\<Mermaid value={\`flowchart TD
Start(\[What do you want to monitor?]) --> Target{Primary target}

```
Target -->|Website or API| Web[Web Property]
Target -->|Network / Infrastructure| Infra[Infrastructure Service]
Target -->|Domains & Edge| Domain[Domain / CDN]
Target -->|Data Pipelines| Data[Data Pipeline]
Target -->|Realtime Channel| Realtime[Realtime Channel]

Web --> WebAspect{Key signal}
WebAspect -->|Availability & latency| HttpGeneral[HTTP (Website/API)]
WebAspect -->|Exact status code| HttpStatus[HTTP Status Code]
WebAspect -->|Header value| HttpHeader[HTTP Header Match]
WebAspect -->|Body keyword| HttpKeyword[HTTP Keyword Match]
WebAspect -->|JSON field| HttpJson[HTTP JSON Match]
WebAspect -->|Latency budget| HttpLatency[HTTP Latency Threshold]
WebAspect -->|Heartbeat payload| Heartbeat[Server Heartbeat]

Infra --> InfraAspect{Protocol}
InfraAspect -->|ICMP reachability| Ping[Ping (Host)]
InfraAspect -->|TCP connectivity| Port[Port (Host/Port)]
InfraAspect -->|TLS certificate| Ssl[SSL Certificate]

Domain --> DomainAspect{Focus}
DomainAspect -->|DNS resolution| Dns[DNS (Domain Resolution)]
DomainAspect -->|Edge drift| Cdn[CDN Edge Consistency]

Data --> DataAspect{Concern}
DataAspect -->|Replication freshness| Replication[Replication Lag]

Realtime --> RealtimeAspect{Channel}
RealtimeAspect -->|WebSocket keepalive| Websocket[WebSocket Keepalive]

HttpGeneral --> HttpGeneralConfig[Configure:<br/>• URL<br/>• Method<br/>• Retry policy]
HttpStatus --> HttpStatusConfig[Configure:<br/>• URL<br/>• Expected status]
HttpHeader --> HttpHeaderConfig[Configure:<br/>• URL<br/>• Header name<br/>• Expected value]
HttpKeyword --> HttpKeywordConfig[Configure:<br/>• URL<br/>• Keyword]
HttpJson --> HttpJsonConfig[Configure:<br/>• URL<br/>• JSON path<br/>• Expected value]
HttpLatency --> HttpLatencyConfig[Configure:<br/>• URL<br/>• Max response time]
Heartbeat --> HeartbeatConfig[Configure:<br/>• URL<br/>• Status path<br/>• Timestamp path<br/>• Expected status]
Ping --> PingConfig[Configure:<br/>• Host/IP<br/>• Packet count<br/>• Thresholds]
Port --> PortConfig[Configure:<br/>• Host/IP<br/>• Port<br/>• TLS option]
Ssl --> SslConfig[Configure:<br/>• Host<br/>• Port<br/>• Warning window]
Dns --> DnsConfig[Configure:<br/>• Domain<br/>• Record type<br/>• Expected value]
Cdn --> CdnConfig[Configure:<br/>• Baseline URL<br/>• Edge URLs]
Replication --> ReplicationConfig[Configure:<br/>• Primary URL<br/>• Replica URL<br/>• Timestamp field<br/>• Max lag]
Websocket --> WebsocketConfig[Configure:<br/>• ws:// or wss:// URL<br/>• Max pong delay]

%% Styling
classDef startNode fill:#e1f5fe,stroke:#0277bd,color:#000000
classDef decision fill:#fff3e0,stroke:#ef6c00,color:#000000
classDef monitorType fill:#e8f5e8,stroke:#2e7d32,color:#000000
classDef config fill:#f3e5f5,stroke:#7b1fa2,color:#000000

class Start startNode
class Target,WebAspect,InfraAspect,DomainAspect,DataAspect,RealtimeAspect decision
class Web,Infra,Domain,Data,Realtime,HttpGeneral,HttpStatus,HttpHeader,HttpKeyword,HttpJson,HttpLatency,Heartbeat,Ping,Port,Ssl,Dns,Cdn,Replication,Websocket monitorType
class HttpGeneralConfig,HttpStatusConfig,HttpHeaderConfig,HttpKeywordConfig,HttpJsonConfig,HttpLatencyConfig,HeartbeatConfig,PingConfig,PortConfig,SslConfig,DnsConfig,CdnConfig,ReplicationConfig,WebsocketConfig config`} />
```

## Error Handling and Recovery Flow

This diagram shows how the system handles errors and implements recovery strategies:

\<Mermaid value={\`stateDiagram-v2
\[\*] --> Monitoring : Start Monitor

```
Monitoring --> Success : Check Passed
Monitoring --> Warning : Partial Failure
Monitoring --> Critical : Total Failure
Monitoring --> Timeout : Request Timeout

Success --> Monitoring : Continue Monitoring
Success --> AlertResolved : Send Resolution Alert
AlertResolved --> Monitoring

Warning --> RetryLogic : Implement Retry
RetryLogic --> Success : Retry Successful
RetryLogic --> Critical : Retry Failed
RetryLogic --> Warning : Partial Recovery

Critical --> ErrorAnalysis : Analyze Error
ErrorAnalysis --> NetworkIssue : Network Problem
ErrorAnalysis --> ServiceDown : Service Unavailable
ErrorAnalysis --> ConfigError : Configuration Issue

NetworkIssue --> RetryWithBackoff : Exponential Backoff
ServiceDown --> AlertCritical : Send Critical Alert
ConfigError --> AlertConfig : Send Config Alert

RetryWithBackoff --> Success : Network Recovered
RetryWithBackoff --> Critical : Network Still Down

AlertCritical --> Monitoring : Continue Monitoring
AlertConfig --> ManualIntervention : Requires Admin

Timeout --> TimeoutRetry : Retry with Longer Timeout
TimeoutRetry --> Success : Timeout Resolved
TimeoutRetry --> Critical : Still Timing Out

ManualIntervention --> Monitoring : Issue Resolved
ManualIntervention --> [*] : Monitor Disabled

Critical --> [*] : Max Retries Exceeded
Success --> [*] : Monitor Stopped`} />
```

:::note
Partial failure states are captured in the monitoring summaries emitted by Electron and surfaced to the renderer as lifecycle telemetry. The current UI surfaces the aggregate counts via notifications and logs rather than a dedicated "partial failure" badge.
:::

## Data Flow and Synchronization Strategy

The current architecture centers on a single standardized cache inside Electron that feeds both IPC responses and broadcast events, while the renderer relies on typed services plus automatic full-sync recovery when payload validation fails:

\<Mermaid value={\`graph TB
subgraph Renderer
UI\[User Interface]
Store\[Zustand Sites Store]
Services\[Renderer Services<br/>(StateSyncService, MonitoringService)]
end

```
subgraph Preload
    Bridge[Context Bridge]
    Guards[Runtime Payload Guards]
end

subgraph Electron
    Orchestrator[UptimeOrchestrator]
    SiteMgr[SiteManager + StandardizedCache]
    MonitorMgr[MonitorManager]
    EventBus[TypedEventBus<UptimeEvents>]
    Database[(SQLite Database)]
end

subgraph External
    Targets[Monitored Targets]
end

UI --> Store
Store --> Services
Services --> Bridge
Bridge --> Guards
Guards --> Orchestrator

Services -->|Full Sync & Commands| Orchestrator
Orchestrator --> SiteMgr
SiteMgr --> Database
SiteMgr --> EventBus

EventBus --> Bridge
Bridge --> Store

MonitorMgr --> SiteMgr
MonitorMgr --> EventBus
MonitorMgr --> Targets
Targets --> MonitorMgr

Store --> UI
```

\`} />

During normal operation the renderer requests an initial snapshot through `StateSyncService.requestFullSync()`, then stays synchronized through `state-sync-event` broadcasts. When an invalid payload is detected, the new automatic recovery flow triggers a guarded full sync and replays a synthetic bulk update so stores never diverge from Electron state.

## Scheduled Monitor Check Lifecycle

This sequence illustrates how a scheduled monitor run traverses the enhanced monitoring stack, from the interval scheduler, through operation correlation, to the renderer update and desktop notifications.

\<Mermaid value={\`sequenceDiagram
autonumber
participant Sched as MonitorScheduler
participant Mgr as MonitorManager
participant Checker as EnhancedMonitorChecker
participant Ops as MonitorOperationRegistry
participant Timeout as OperationTimeoutManager
participant StatusSvc as MonitorStatusUpdateService
participant HistRepo as HistoryRepository
participant MonRepo as MonitorRepository
participant Cache as Sites Cache
participant Bus as TypedEventBus<UptimeEvents>
participant AppSvc as ApplicationService
participant Notify as NotificationService
participant RendererBridge as RendererEventBridge
participant Preload as Preload Events API
participant Renderer as Renderer EventsService
participant Stores as Zustand Stores & UI

```
Sched->>Mgr: handleScheduledCheck(siteIdentifier, monitorId)
Mgr->>Mgr: Lookup site in cache
Mgr->>Checker: checkMonitor(site, monitorId, false)

Checker->>Ops: initiateCheck(monitorId)
Ops-->>Checker: operationId + AbortSignal
Checker->>Timeout: scheduleTimeout(operationId, timeoutMs)
Note right of Checker: Combined AbortSignal protects against hung probes.

Checker->>Checker: executeMonitorCheck (type-specific service)
Checker->>HistRepo: saveHistoryEntry(result)
Checker->>StatusSvc: updateMonitorStatus(result)

StatusSvc->>Ops: validateOperation(operationId)
alt Operation cancelled or monitor paused
    StatusSvc-->>Checker: ignore result
else Operation active
    StatusSvc->>MonRepo: persist status & responseTime
    StatusSvc->>Cache: refresh StandardizedCache
    StatusSvc->>Ops: completeOperation(operationId)
    StatusSvc->>Timeout: clearTimeout(operationId)
    StatusSvc-->>Checker: update applied
end

opt Update applied
    Checker->>Bus: emit monitor:status-changed
    alt Result == "down"
        Checker->>Bus: emit monitor:down
    else Result == "up"
        Checker->>Bus: emit monitor:up
    end
end

Bus->>AppSvc: typed event handler invoked
AppSvc->>Notify: notifyMonitorDown/Up(site, monitorId)
AppSvc->>RendererBridge: sendToRenderers(channel, payload)
RendererBridge->>Preload: webContents.send(channel, payload)
Preload->>Renderer: window.electronAPI.events.dispatch(channel, payload)
Renderer->>Stores: apply typed update & append history
Stores->>UI: Re-render dashboards
```

\`} />

***

These workflow diagrams provide detailed insights into how Uptime Watcher processes monitoring tasks, handles errors, and manages data flow throughout the system.

```
      </div>
    </div>
  </div>
</Layout>
```

);
}
